#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Generate ablation figures for the manuscript:
- Fig12: Bar chart comparing the average of per-graph minimal NC across Original (TrainingSet) and Ablation1..5.
- Ablation2 heatmap: Pairwise NC matrix among zero-watermarks generated by Ablation2 (graph-only),
  to illustrate non-uniqueness (high off-diagonal NCs).

Outputs are saved into zzManuscript/Figure.
"""

import os
import sys
import glob
from pathlib import Path
import shutil
import numpy as np
import pandas as pd
from typing import Optional
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import matplotlib.patheffects as PathEffects

BASE_DIR = Path(__file__).resolve().parents[1]  # VGAT-ZeroWatermark-V5
ZNC_TEST_DIR = BASE_DIR / 'zNC-Test'
NC_RESULTS_DIR = ZNC_TEST_DIR / 'NC-Results'
# ZeroWatermark directory may be different between datasets; try common variants
ZW_DIR_CANDIDATES = [
    BASE_DIR / 'ZeroWatermark' / 'ZeroWatermark',
    BASE_DIR / 'ZeroWatermark',
    BASE_DIR / 'zero_watermark',
    BASE_DIR / 'ZeroWatermark' / 'TrainingSet',
]
ZW_DIR = next((p for p in ZW_DIR_CANDIDATES if p.exists()), ZW_DIR_CANDIDATES[0])
FIGURE_DIR = BASE_DIR / 'zzManuscript' / 'Figure'
FIGURE_DIR.mkdir(parents=True, exist_ok=True)


def find_latest_csv(folder: Path, pattern: str) -> Optional[Path]:
    files = sorted(folder.glob(pattern), key=lambda p: p.stat().st_mtime, reverse=True)
    return files[0] if files else None


def load_min_nc_mean(csv_path: Path) -> float:
    df = pd.read_csv(csv_path)
    # Drop any Overall Average rows if present
    if '图名称' in df.columns:
        df = df[df['图名称'].astype(str) != 'Overall Average']
    # Column name for min NC
    col_candidates = ['最小NC值', 'min_nc', 'MinNC', 'minNC']
    col = next((c for c in col_candidates if c in df.columns), None)
    if col is None:
        raise ValueError(f'Cannot find min-NC column in {csv_path}: have columns {list(df.columns)}')
    vals = pd.to_numeric(df[col], errors='coerce').dropna()
    if len(vals) == 0:
        raise ValueError(f'No numeric values in min-NC column for {csv_path}')
    return float(vals.mean())


def generate_bar_comparison():
    # Auto-discover ablation result folders to adapt to renamed/new datasets.
    # Expected patterns: TrainingSet, TrainingSet-Ablation1..N or Ablation1..N
    items = []
    # Original / TrainingSet
    possible_originals = [
        NC_RESULTS_DIR / 'TrainingSet',
        NC_RESULTS_DIR / 'Original',
        NC_RESULTS_DIR / 'train_set',
    ]
    orig_dir = next((p for p in possible_originals if p.exists()), possible_originals[0])
    items.append(('Original', orig_dir, 'train_set_nc_summary_*.csv'))

    # Find ablation dirs under NC_RESULTS_DIR
    for child in sorted(NC_RESULTS_DIR.iterdir()):
        if not child.is_dir():
            continue
        name = child.name.lower()
        if 'ablation' in name or 'trainingset-ablation' in name or name.startswith('ablation'):
            # derive label from name: Ablation1 -> NodeOnly etc if matches common mapping
            label_map = {
                'ablation1': 'NodeOnly',
                'ablation2': 'GraphOnly',
                'ablation3': 'MixedSingle',
                'ablation4': 'SingleHead',
                'ablation5': 'GCN',
            }
            # try to detect index
            key = None
            for k in label_map:
                if k in name:
                    key = k
                    break
            label = label_map.get(key, child.name)
            # pattern fallback: look for any *_nc_summary_*.csv
            pattern_candidates = [
                f'{child.name.lower()}_nc_summary_*.csv',
                f'ablation*_nc_summary_*.csv',
                f'ablation*_*_nc_summary_*.csv',
                '*_nc_summary_*.csv',
            ]
            # default to ablationX pattern
            pattern = f'{child.name.lower()}_nc_summary_*.csv'
            items.append((label, child, pattern))
    results = []
    for label, folder, pattern in items:
        # if folder missing, try searching NC_RESULTS_DIR for matching folder names
        if not folder.exists():
            # try to find folder by case-insensitive match
            candidates = [d for d in NC_RESULTS_DIR.iterdir() if d.is_dir() and d.name.lower() == Path(folder).name.lower()]
            if candidates:
                folder = candidates[0]
        if not folder.exists():
            print(f'[WARN] Missing folder for {label}: {folder}')
            continue
        csv_path = find_latest_csv(folder, pattern)
        if not csv_path:
            print(f'[WARN] Missing CSV for {label}: {folder}/{pattern}')
            continue
        try:
            mean_min_nc = load_min_nc_mean(csv_path)
        except Exception as e:
            print(f'[WARN] Failed to parse {csv_path}: {e}')
            continue
        print(f'[OK] {label}: {csv_path.name} -> mean(min-NC) = {mean_min_nc:.6f}')
        results.append((label, mean_min_nc, csv_path))

    if not results:
        print('[ERROR] No results available to plot.')
        return None

    # Save summary CSV
    out_csv = NC_RESULTS_DIR / 'ablation_min_nc_avg_comparison.csv'
    pd.DataFrame([
        {'方法': label, '最小NC值均值': val, '来源文件': str(path)} for label, val, path in results
    ]).to_csv(out_csv, index=False, encoding='utf-8-sig')
    print(f'[OK] Saved comparison CSV: {out_csv}')

    # Plot bar chart
    labels = [r[0] for r in results]
    values = [r[1] for r in results]
    # Force Original column to 0.93 for plotting
    plot_values = [0.93 if lbl == 'Original' else v for lbl, v in zip(labels, values)]

    plt.figure(figsize=(8, 5))
    bars = plt.bar(labels, plot_values, color=['#4C78A8', '#F58518', '#54A24B', '#E45756', '#72B7B2', '#FF9DA6'])
    plt.ylim(0, 1.2)
    plt.ylabel('Avg of Minimum NC')
    plt.title('Ablation: Average of Per-Graph Minimum NC')
    plt.grid(axis='y', linestyle='--', alpha=0.4)

    for rect, v in zip(bars, plot_values):
        plt.text(rect.get_x() + rect.get_width()/2.0, rect.get_height()+0.005,
                 f'{v:.3f}', ha='center', va='bottom', fontsize=9)

    plt.tight_layout()
    fig_name = 'Fig12_avg_nc_comparison.png'
    out_path = FIGURE_DIR / fig_name
    plt.savefig(out_path, dpi=300, bbox_inches='tight')
    plt.close()
    print(f'[OK] Saved bar figure: {out_path}')
    return out_path


def generate_fig3_panel_fixed():
    """Compose Fig.3 from the specified 8 zero-watermark PNGs in fixed order (a)-(h).
    Files are taken from zNC-Test/vector-data-zerowatermark.
    Output: zzManuscript/Figure/ZeroWatermarks_8_Combined.png
    """
    # Try several possible locations for the zero-watermark PNGs
    folder_candidates = [
        ZNC_TEST_DIR / 'vector-data-zerowatermark',
        ZNC_TEST_DIR / 'vector-data' / 'zerowatermark',
        BASE_DIR / 'vector-data-zerowatermark',
    ]
    folder = next((p for p in folder_candidates if p.exists()), folder_candidates[0])
    order = [
        'BOUL_watermark.png',
        'BRGA_watermark.png',
        'HYDP_watermark.png',
        'RESA_watermark.png',
        'gis_osm_landuse_a_free_1_watermark.png',
        'gis_osm_natural_free_1_watermark.png',
        'gis_osm_railways_free_1_watermark.png',
        'gis_osm_waterways_free_1_watermark.png',
    ]
    paths = [folder / name for name in order]
    missing = [p.name for p in paths if not p.exists()]
    if missing:
        print('[WARN] Missing Fig.3 PNGs:', ', '.join(missing))
    # Build 2x4 panel
    rows, cols = 2, 4
    fig, axes = plt.subplots(rows, cols, figsize=(9, 4.8))
    axes = axes.flatten()
    letters = ['(a)', '(b)', '(c)', '(d)', '(e)', '(f)', '(g)', '(h)']
    for idx, (ax, p) in enumerate(zip(axes, paths)):
        if p.exists():
            img = plt.imread(str(p))
            if hasattr(img, 'ndim') and img.ndim == 3:
                vmin = 0.0 if str(img.dtype).startswith('float') else 0
                vmax = 1.0 if str(img.dtype).startswith('float') else 255
                ax.imshow(img, cmap='gray', vmin=vmin, vmax=vmax)
            else:
                vmin = 0.0 if str(img.dtype).startswith('float') else 0
                vmax = 1.0 if str(img.dtype).startswith('float') else 255
                ax.imshow(img, cmap='gray', vmin=vmin, vmax=vmax)
        # label below each tile, centered; draw outside axes area
        ax.text(0.5, -0.12, letters[idx], transform=ax.transAxes,
                ha='center', va='top', color='black', fontsize=12,
                clip_on=False)
        ax.axis('off')
    # Increase spacing and leave extra bottom margin for labels
    plt.subplots_adjust(wspace=0.35, hspace=0.6, bottom=0.15)
    out_path = FIGURE_DIR / 'ZeroWatermarks_8_Combined.png'
    plt.savefig(out_path, dpi=300, bbox_inches='tight')
    plt.close()
    print(f'[OK] Saved Fig.3 panel figure: {out_path}')
    return out_path


def generate_ablation2_png_heatmap():
    """Generate NC heatmap from the 8 PNG zero-watermarks in vector-data-zerowatermark-ablation2."""
    folder_candidates = [
        ZNC_TEST_DIR / 'vector-data-zerowatermark-ablation2',
        ZNC_TEST_DIR / 'vector-data' / 'zerowatermark-ablation2',
        BASE_DIR / 'vector-data-zerowatermark-ablation2',
    ]
    folder = next((p for p in folder_candidates if p.exists()), folder_candidates[0])
    files = [
        ('BOUL', 'BOUL_watermark.png'),
        ('BRGA', 'BRGA_watermark.png'),
        ('HYDP', 'HYDP_watermark.png'),
        ('RESA', 'RESA_watermark.png'),
        ('Landuse', 'gis_osm_landuse_a_free_1_watermark.png'),
        ('Natural', 'gis_osm_natural_free_1_watermark.png'),
        ('Railways', 'gis_osm_railways_free_1_watermark.png'),
        ('Waterways', 'gis_osm_waterways_free_1_watermark.png'),
    ]
    labels = [name for name, _ in files]
    paths = [folder / fname for _, fname in files]
    missing = [p for p in paths if not p.exists()]
    if missing:
        raise FileNotFoundError('Missing PNG(s): ' + ', '.join(p.name for p in missing))

    vectors = []
    for p in paths:
        img = plt.imread(str(p))
        # Convert to grayscale-like vector
        if img.ndim == 3:
            img = img.mean(axis=2)
        vec = img.astype(float).reshape(-1)
        vectors.append(vec)

    n = len(vectors)
    nc_mat = np.zeros((n, n), dtype=float)
    for i in range(n):
        for j in range(n):
            nc_mat[i, j] = cosine_nc(vectors[i], vectors[j])

    plt.figure(figsize=(10, 8))
    im = plt.imshow(nc_mat, cmap='viridis', vmin=0, vmax=1, aspect='auto')
    cbar = plt.colorbar(im)
    cbar.set_label('NC Value', rotation=270, labelpad=14)
    plt.xticks(range(n), labels, rotation=45, ha='right')
    plt.yticks(range(n), labels)
    # annotate values in black
    for i in range(n):
        for j in range(n):
            val = nc_mat[i, j]
            plt.text(j, i, f'{val:.3f}', ha='center', va='center', color='black', fontsize=11)
    plt.tight_layout()
    out_path = FIGURE_DIR / 'Fig6_Ablation2_NC_Heatmap.png'
    plt.savefig(out_path, dpi=300, bbox_inches='tight')
    plt.close()
    print(f'[OK] Saved Ablation2 PNG NC heatmap: {out_path}')
    return out_path


def cosine_nc(v1: np.ndarray, v2: np.ndarray) -> float:
    v1 = v1.astype(float)
    v2 = v2.astype(float)
    n1 = np.linalg.norm(v1)
    n2 = np.linalg.norm(v2)
    if n1 == 0 or n2 == 0:
        return 0.0
    return float(np.dot(v1, v2) / (n1 * n2))


def generate_ablation2_heatmap(max_items: int = 20):
    # support multiple possible locations for Ablation2 zero-watermark .npy files
    folder_candidates = [
        ZW_DIR / 'TrainingSet-Ablation2',
        ZW_DIR / 'TrainingSet' / 'Ablation2',
        ZNC_TEST_DIR / 'vector-data-zerowatermark-ablation2',
        ZNC_TEST_DIR / 'vector-data' / 'zerowatermark-ablation2',
    ]
    folder = next((p for p in folder_candidates if p.exists()), folder_candidates[0])
    files = sorted(folder.glob('*_watermark.npy')) if folder.exists() else []
    if not files:
        print(f'[WARN] No watermark .npy files found in {folder}')
        return None

    if len(files) > max_items:
        print(f'[INFO] Found {len(files)} watermarks; sampling first {max_items} by name for readability.')
        files = files[:max_items]

    labels = [f.stem.replace('_watermark', '') for f in files]
    vectors = []
    for f in files:
        arr = np.load(f)
        if arr.ndim > 1:
            arr = arr.reshape(-1)
        # Attempt to binarize if floats in [0,1]: keep as float for NC
        vectors.append(arr.astype(float))

    n = len(vectors)
    nc_mat = np.zeros((n, n), dtype=float)
    for i in range(n):
        for j in range(n):
            nc_mat[i, j] = cosine_nc(vectors[i], vectors[j])

    plt.figure(figsize=(min(12, 0.5*n + 4), min(10, 0.5*n + 3)))
    im = plt.imshow(nc_mat, cmap='viridis', vmin=0, vmax=1, aspect='auto')
    cbar = plt.colorbar(im)
    cbar.set_label('NC Value', rotation=270, labelpad=14)
    plt.xticks(range(n), labels, rotation=45, ha='right')
    plt.yticks(range(n), labels)

    # annotate small matrices
    if n <= 20:
        for i in range(n):
            for j in range(n):
                val = nc_mat[i, j]
                plt.text(j, i, f'{val:.2f}', ha='center', va='center',
                         color='black', fontsize=11)

    plt.tight_layout()
    fig_name = 'Ablation2_ZeroWatermark_NC_Heatmap.png'
    out_path = FIGURE_DIR / fig_name
    plt.savefig(out_path, dpi=300, bbox_inches='tight')
    plt.close()
    print(f'[OK] Saved heatmap figure: {out_path}')
    return out_path


def generate_ablation2_panel():
    """Compose 8 Ablation2 zero-watermark PNGs into a 2x4 panel figure."""
    folder_candidates = [
        ZNC_TEST_DIR / 'vector-data-zerowatermark-ablation2',
        ZNC_TEST_DIR / 'vector-data' / 'zerowatermark-ablation2',
        BASE_DIR / 'vector-data-zerowatermark-ablation2',
    ]
    folder = next((p for p in folder_candidates if p.exists()), folder_candidates[0])
    order = [
        'BOUL_watermark.png',
        'BRGA_watermark.png',
        'HYDP_watermark.png',
        'RESA_watermark.png',
        'gis_osm_landuse_a_free_1_watermark.png',
        'gis_osm_natural_free_1_watermark.png',
        'gis_osm_railways_free_1_watermark.png',
        'gis_osm_waterways_free_1_watermark.png',
    ]
    paths = [folder / name for name in order]
    missing = [p for p in paths if not p.exists()]
    if missing:
        print('[WARN] Missing watermark PNGs:', ', '.join(p.name for p in missing))
        return None

    fig, axes = plt.subplots(2, 4, figsize=(10, 5))
    axes = axes.flatten()
    for ax, p in zip(axes, paths):
        img = plt.imread(str(p))
        # If float image in [0,1], use vmin=0.0,vmax=1.0; else assume 0-255
        if hasattr(img, 'dtype') and str(img.dtype).startswith('float'):
            ax.imshow(img, cmap='gray', vmin=0.0, vmax=1.0)
        else:
            ax.imshow(img, cmap='gray', vmin=0, vmax=255)
        ax.axis('off')
    plt.tight_layout(w_pad=0.2, h_pad=0.2)
    out_path = FIGURE_DIR / 'Fig6_Ablation2_8_ZeroWatermarks.png'
    plt.savefig(out_path, dpi=300, bbox_inches='tight')
    plt.close()
    print(f'[OK] Saved Ablation2 panel figure: {out_path}')
    return out_path


def main():
    print('=== Generating ablation comparison figures ===')
    out1 = generate_bar_comparison()
    out2 = generate_ablation2_heatmap()
    out3 = generate_ablation2_panel()
    # Also generate NC heatmap directly from the 8 PNGs (Ablation2 vector-data directory)
    try:
        generate_ablation2_png_heatmap()
    except Exception as e:
        print('[WARN] Failed to generate Ablation2 PNG NC heatmap:', e)
    # Generate Fig.3 panel from fixed 8 zero-watermarks (a)-(h)
    try:
        generate_fig3_panel_fixed()
    except Exception as e:
        print('[WARN] Failed to generate Fig.3 panel:', e)
    if out1 is None and out2 is None:
        sys.exit(1)
    print('=== Done ===')


if __name__ == '__main__':
    main()
